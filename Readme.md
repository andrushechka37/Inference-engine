# Машина вывода
Машина вывода — программа, которая выполняет логический вывод из предварительно построенной базы фактов и правил.

# Моя реализация машины вывода
## Как использовать?
```
git clone https://github.com/andrushechka37/Inference-engine.git
```

Записываем правила и факты в файл input.txt
Пример:
```
a = 1;
b = 0;
c = 0;
-
((!a & b) | c) ? a = 0, b = 1;
() ? c = 1, b = 0, a = 0;
```
Сначала идет присвоение переменных, в именах переменных могут использоваться только английские буквы. В конце каждого присвоения должна стоять точка с запятой.

После присвоения начальных значений должна стоять отделяющая черта `-`.

Правила строются по следующим правилам:
`(`какое-то логическое выражение`)` `?` набор присвоений вида (a `=` 0), в случае нескольких переменных они перечисляются через запятую. В конце должна стоять точка с запятой.

После заполнения input.txt поочередно выполняем команды `make rules` и `make engine`. Отчет о работе машины находится в файле report.txt.
```
the rule № 1 worked
the rule № 2 worked
a: 1 -> 0
b: 0 -> 0
c: 0 -> 1

------------------

a: 0 -> 0
b: 0 -> 0
c: 1 -> 1

------------------
```

## Нюансы реализации
Для игнорирования пробельных символов была применена токенизация ввода. 

Написанные правила транслируются в C, чтобы их include`ить при выполнении программы. Возможно это не самая очевидная реализация, но она позваляет обрабатывать сложные выражения, не пребегая к алгоритму рекурсивного спуска для правильного считывания правил. Также это позволяет избежать многократных считываний из ввода.

Пример трансляции:

`((!a & b) | c) ? a = 0, b = 1;` транслируется в 
```
if ((!variables->data[0].value && variables->data[1].value) || variables->data[2].value) {
variables->data[0].value = 0;
variables->data[1].value = 1;

is_change = 1;
fprintf(report, "the rule № 1 worked\n");
}
```

У данного подхода есть минус, пришлось разделить программу на 2 части(генерацию правил и их выполение). Так как не получилось реализовать единую версию. 

На мой взгяд лаконичность и простота этого подхода перекрывает данный минус.


# Ответы на допвопросы:
1. пока не придумал
2. вроде нет
3. Машина может не остановиться, если в системе присутствуют циклические зависимости. Например:

Правило 1: Если A, то B = True
Правило 2: Если B, то A = True

Решения:
* Ввести ограничение на максимальное количество циклов.
* Предусмотреть механизм обнаружения циклических зависимостей.